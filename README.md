# Tauri + React + Typescript

This template should help get you started developing with Tauri, React and Typescript in Vite.

## Recommended IDE Setup

- [VS Code](https://code.visualstudio.com/) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)

🚀 **Tauri v2 트리거 기반 비주얼 프로그래밍 툴 - 프로젝트 현황** (2025-07-01 업데이트)

## 🎯 **프로젝트 목표**

### **비전**: Langflow와 차별화된 트리거 기반 워크플로우 에디터
- **기존 Langflow**: 자동 실행, 채팅형 인터페이스
- **우리 프로젝트**: **트리거 기반 수동 제어**, 이벤트 드리븐 워크플로우
- **기술 스택**: Tauri Framework v2 + React + TypeScript
- **핵심 차별점**: 각 노드가 개별 시작점이 될 수 있는 유연한 구조

### **최종 목표**:
1. **초보자도 쉽게**: 코딩 없이 복잡한 자동화 워크플로우 구성
2. **확장성**: 노드 추가가 매우 쉬운 구조
3. **실용성**: 실제 업무에서 사용 가능한 자동화 도구
4. **배포 용이성**: 단일 .exe 파일로 배포 가능

## ✅ **완성된 핵심 시스템들**

### 1. **트리거 체인 엔진 (완벽 작동 ✅)**
```
[시작노드] --트리거--> [파일생성노드] --트리거--> [다음노드들...]
```
- **개별 실행**: 어떤 노드든 워크플로우 시작점 가능
- **연쇄 실행**: 완료된 노드가 자동으로 다음 노드들 트리거
- **병렬 실행**: 한 노드에서 여러 노드로 동시 분기
- **자동 상태 복귀**: 실행완료 후 2초 뒤 자동으로 "대기중"으로 복귀
- **실행 흐름**: `executeNextNodes()` → `triggerExecution: Date.now()` → `useEffect` 감지

### 2. **완전 자동 노드 등록 시스템 (프론트엔드 + 백엔드)**
- **프론트엔드**: `src/nodes/*.tsx` 파일 자동 스캔
- **백엔드**: `src-tauri/src/nodes/*.rs` 파일 구조화
- **1:1 대응**: 파일명과 함수명 완전 일치
- **Zero Configuration**: 기존 코드 수정 없이 노드 추가

### 3. **표준화된 노드 아키텍처**
**4단 구조 (Langflow 스타일)**:
1. **헤더**: 아이콘 + 이름 + 개별실행버튼 + 동적 설명
2. **트리거**: 상태표시 + 트리거 입출력 핸들
3. **입력**: 데이터 입력 필드들 (핸들 연결시 비활성화)
4. **출력**: 실행 결과 표시

**핸들 시스템**:
- 🟢 **초록 핸들**: 트리거 (실행 흐름 제어)
- 🟡 **노랑 핸들**: 데이터 (연결시), 회색 (비연결시)

**상태 관리**:
- "대기중" → "실행중..." → "실행완료"/"실행실패" → (2초 후) "대기중"

### 4. **완성된 노드들 (3개)**

**StartNode (워크플로우 시작)**:
- 🚀 수동 트리거 시작점
- 기능: 워크플로우 초기화 및 다음 노드 체인 시작
- 출력: 트리거만
- 파일: `StartNode.tsx` ↔ `start_node.rs` → `start_node()`

**FileCreatorNode (텍스트 파일 생성)**:
- 📄 파일 시스템 조작
- 입력: 파일경로, 파일이름, 파일내용
- 기능: 텍스트 파일 생성, 디렉토리 자동 생성
- 출력: 트리거 + 생성된 파일 경로 + 파일 정보
- 파일: `FileCreatorNode.tsx` ↔ `file_creator_node.rs` → `file_creator_node()`

**TextInputNode (텍스트 데이터 제공)**:
- 📝 텍스트 데이터 소스
- 입력: 사용자 입력 텍스트
- 기능: 다른 노드들에게 텍스트 데이터 제공
- 출력: 텍스트 데이터
- 파일: `TextInputNode.tsx` (백엔드 호출 없음)

### 5. **백엔드 자동 등록 아키텍처**
```rust
// src-tauri/src/lib.rs - 자동 등록 시스템
mod nodes;
use nodes::*;

.invoke_handler(tauri::generate_handler![
    start_node,
    file_creator_node,
    // 새 노드는 여기에 한 줄만 추가
])
```

**디렉토리 구조**:
```
src-tauri/src/nodes/
├── mod.rs (자동 등록 관리)
├── start_node.rs
├── file_creator_node.rs  
└── workflow_storage.rs (공통 기능)
```

### 6. **고급 사이드바 시스템**
- **자동 노드 발견**: config export를 통한 완전 자동화
- **카테고리 분류**: Core, File, Data, Text 등 자동 분류
- **검색 기능**: 실시간 노드 검색 및 필터링
- **드래그앤드롭**: 캔버스에 노드 추가
- **확장/축소**: 카테고리별 토글 기능

### 7. **성능 최적화 완료**
- **메모이제이션**: 핸들 연결 상태, 함수들 최적화
- **Context API**: WorkflowContext로 상태 공유 최적화
- **배치 업데이트**: 노드 상태 변경 최소화
- **메모리 효율성**: 불필요한 재렌더링 방지
- **타입 안전성**: 중앙화된 타입 정의로 완전한 TypeScript 활용

### 8. **워크플로우 영속성**
- **저장**: 바탕화면에 `workflow.flow.json`
- **복원**: 노드 위치, 연결, 설정값 모두 보존
- **추가 로드**: 기존 워크플로우에 새 워크플로우 추가
- **호환성**: React Flow 표준 포맷 사용

### 9. **데이터 파이프라인 시스템**
- **실시간 동기화**: 연결된 노드 간 데이터 자동 전달
- **타입 안전 전송**: 각 노드의 출력이 연결된 노드의 입력으로 안전하게 전달
- **시각적 피드백**: 연결 상태에 따른 입력 필드 비활성화
- **출력 데이터 관리**: `outputData` 시스템으로 노드 간 데이터 공유

## 🎮 **현재 작동 방식**

### **사용자 시나리오**:
1. **노드 배치**: 사이드바에서 드래그앤드롭으로 노드들 배치
2. **연결**: 핸들끼리 드래그해서 연결 (초록-초록, 노랑-노랑)
3. **설정**: 각 노드의 입력값 설정
4. **실행**: 아무 노드나 "실행" 버튼 클릭
5. **자동화**: 연결된 모든 노드들이 순차적으로 자동 실행
6. **복귀**: 각 노드는 실행 완료 후 2초 뒤 자동으로 "대기중"으로 복귀

### **실제 테스트 결과** (2025-07-01 확인):
```
🚀 워크플로우 시작!               ← StartNode 실행
✅ 시작노드 완료: 시작 완료         ← 백엔드 호출 성공  
🔗 1 완료 → 다음 노드들 찾는 중...  ← 트리거 체인 시작
➡️ 다음 노드들 실행: 2            ← 다음 노드 발견
📄 파일생성 노드 2 자동실행 트리거됨! ← 연쇄 실행 성공
📄 파일생성: /path/file.txt       ← 파일 생성 완료
⏰ 2초 후 모든 노드 "대기중" 복귀   ← 자동 상태 리셋
```
**→ 트리거 체인 + 자동 복귀 + 데이터 파이프라인 완벽 작동 확인됨!**

## 📁 **현재 파일 구조**

```
src/                           # 프론트엔드
├── App.tsx                    # ReactFlowProvider + 레이아웃
├── Workspace.tsx              # 메인 캔버스 + 트리거 체인 엔진
├── Sidebar.tsx                # 노드 라이브러리 + 드래그앤드롭
├── WorkflowContext.tsx        # Context API로 상태 공유
├── NodeManager.ts             # ID 관리 + 타이머 관리
├── types.ts                   # 중앙화된 타입 정의
└── nodes/                     # 노드 컴포넌트들
    ├── Basenode.tsx           # 공통 노드 기반 클래스
    ├── StartNode.tsx          # 시작 노드
    ├── FileCreatorNode.tsx    # 파일 생성 노드
    └── TextInputNode.tsx      # 텍스트 입력 노드

src-tauri/src/                 # 백엔드
├── main.rs                    # Tauri 엔트리 포인트
├── lib.rs                     # 자동 등록 시스템
└── nodes/                     # 노드 함수들 (구조화됨)
    ├── mod.rs                 # 자동 등록 관리
    ├── start_node.rs          # 시작 노드 함수
    ├── file_creator_node.rs   # 파일 생성 노드 함수
    └── workflow_storage.rs    # 워크플로우 저장/로드
```

## 🔧 **기술 스택**
- **프레임워크**: Tauri v2 (Rust + Web)
- **프론트엔드**: React 18 + TypeScript
- **워크플로우**: @xyflow/react (React Flow)
- **상태관리**: React Flow 내장 + Context API
- **아이콘**: Lucide React
- **스타일링**: CSS Modules + 인라인 스타일
- **빌드**: Vite + Rust Cargo

## 🚀 **노드 추가 가이드 (새 AI를 위한 명확한 규칙)**

### **🎯 개발 철학**:
- **한 번에 한 파일씩**: 절대 여러 파일을 동시에 생성하지 말 것
- **순서대로 생성**: 프론트엔드 → 백엔드 → 등록 → 테스트 순서
- **1:1 완벽 대응**: 파일명과 함수명이 완전히 일치해야 함

### **📋 새 노드 추가 단계**:

**1단계: 프론트엔드 노드 생성** (한 파일만)
```typescript
// src/nodes/MyNewNode.tsx 생성
// 표준 4단 구조 사용
// config export 필수
```

**2단계: 백엔드 함수 생성** (한 파일만)  
```rust
// src-tauri/src/nodes/my_new_node.rs 생성
#[tauri::command]
pub fn my_new_node() -> Result<String, String>
```

**3단계: 백엔드 등록** (mod.rs 수정)
```rust
// src-tauri/src/nodes/mod.rs에 2줄 추가
pub mod my_new_node;
pub use my_new_node::my_new_node;
```

**4단계: 핸들러 등록** (lib.rs 수정)
```rust
// src-tauri/src/lib.rs에 1줄 추가
my_new_node, // 이 한 줄만 추가
```

### **📝 파일명 규칙 (엄격히 준수)**:
- **프론트엔드**: `CamelCaseNode.tsx` 
- **백엔드**: `snake_case_node.rs`
- **함수명**: `snake_case_node()`
- **워크스페이스 내에 보여지는 노드의 큰이름** : `Snake Case`
- **노드 타입**: `camelCaseNode` (첫 글자 소문자)

### **🔥 절대 금지사항**:
- 여러 파일 동시 생성 (한 번에 하나씩만!)
- 파일명 불일치 (프론트엔드-백엔드 1:1 대응 필수)
- 기존 파일 수정 시 다른 파일 동시 변경
- config export 누락

## 🎯 **다음 우선순위 작업들**

### **1순위: 기본 노드 확장** (즉시 시작 가능):
- **TextTransformNode**: 텍스트 변환 (대소문자, 치환, 추출)
- **DelayNode**: 지연 실행 (N초 대기 후 다음 노드 실행)
- **FileReadNode**: 텍스트 파일 읽기
- **ConditionalNode**: 조건분기 (IF문)

### **2순위: UI/UX 개선**:
- 실행 상태 애니메이션 개선
- 에러 처리 시각적 피드백
- 노드 테마/색상 커스터마이징
- 툴팁 시스템

### **3순위: 고급 기능**:
- **변수 시스템**: 노드 간 복잡한 데이터 공유
- **루프 구조**: 반복 실행 노드
- **외부 트리거**: 파일 감지, 시간 기반 자동 실행
- **노드 그룹화**: 서브 워크플로우

### **4순위: 배포 및 최적화**:
- **실행파일 최적화**: 번들 크기 최소화
- **사용자 가이드**: 노드별 도움말
- **예제 워크플로우**: 템플릿 제공
- **성능 최적화**: 대용량 워크플로우 지원

## 🎯 **핵심 설계 원칙들**

1. **단순함 우선**: 복잡한 구조보다 직관적인 사용성
2. **확장성**: 새 노드 추가가 쉬워야 함 (4단계 프로세스)
3. **안정성**: 한 노드 실패가 전체에 영향 안 줌
4. **재사용성**: 워크플로우 저장/공유 가능
5. **성능**: 대용량 데이터도 처리 가능해야 함
6. **일관성**: 모든 노드가 동일한 패턴 따름
7. **타입 안전성**: TypeScript 활용한 런타임 에러 방지

## 🎉 **현재 달성도**

✅ **완성 (90%)**: 
- 핵심 엔진 (트리거 체인 + 자동 복귀)
- 완전 자동 노드 등록 시스템  
- 표준화된 노드 아키텍처
- 데이터 파이프라인 시스템
- 고급 사이드바 시스템
- 성능 최적화
- 저장/불러오기
- 타입 시스템 완비

🚧 **진행 중 (10%)**:
- 더 많은 노드 타입
- 고급 기능들
- UI/UX 개선

## 🌟 **프로젝트의 독창성**

**기존 Langflow와의 차별점**:
1. **트리거 기반**: 사용자가 직접 제어하는 실행 흐름
2. **자동 상태 복귀**: 실행 후 자연스러운 상태 순환
3. **데스크톱 앱**: 웹이 아닌 네이티브 성능
4. **초간단 확장**: 파일 추가만으로 새 기능
5. **완전 자동화**: 설정 파일 없는 제로 컨피그
6. **데이터 파이프라인**: 실시간 노드 간 데이터 동기화

**→ Langflow의 장점(노드 기반 UI) + 우리만의 독창성(트리거 기반 + 자동 복귀 + 데이터 파이프라인)을 결합한 차세대 워크플로우 도구!**

## 💡 **새 AI에게 전달사항**

### **작업 방식**:
- 사용자가 "파일 하나 만들어줘"라고 하면 정말 파일 하나만 생성
- 다음 파일은 사용자가 별도로 요청할 때까지 기다림
- 여러 파일이 필요해도 순서대로 하나씩 진행

### **노드 생성 순서**:
1. 프론트엔드 .tsx 파일 생성
2. 사용자 확인 후 백엔드 .rs 파일 생성  
3. 사용자 확인 후 mod.rs 수정
4. 사용자 확인 후 lib.rs 수정

### **코드 품질**:
- 기존 패턴 완전히 따름
- 성능 최적화 패턴 적용
- TypeScript 타입 안전성 보장
- 에러 처리 포함
- Context API 활용

**이 프로젝트는 단순함과 확장성을 완벽하게 균형잡은 성숙한 시스템입니다!**